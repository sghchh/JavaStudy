#Java泛型  
方法中的形参代表变量，常量，表达式等数据，把他们称为形参，或者是数据形参。定义方法时可以声明数据形参，再调用方法时必须为这些数据形参传入实际的数据。所谓泛型就是允许在定义接口，类，方法的时候使用**类型形参**，这个类型形参在声明变量，创建对象，调用方法的时候必须指明。也就是说，在定义的时候使用“模糊”的类型，在使用的时候就必须制定确切的类型了。  
看示例：  

	//定义的时候可以使用泛型
	public class People<T>{
		public T t;
	//虽然定义类的时候用到了泛型，但是定义构造器的时候不能用<>菱形语法
		public People(T t){
			this.t=t;
		}
	}
	//这是使用的时候，使用的时候就必须为类型形参指定确切的值
	class Person extends People<String>{
		public Person(String s){
			super(s);
		}
	}  
是指泛型参数的上限是：<T extends Object>
通配符的上限也是：<? extends Object>  
下限分别是：<T super String>,<? super String>  

**泛型使用的核心是：定义的时候可以使用泛型，使用的时候必须确定这个泛型的确切类型**  
##定义的时候  
在定义一个接口或者类的时候，如果这个接口或者类的成员中（包括静态和非静态）要用到泛型，那么这个类或者接口的后面必须用“菱形语法”  

	//因为People的成员中有一个T类型，使用到了泛型，所以People后面必须用菱形语法
	public class People<T>{
		public T t;
	//虽然定义类的时候用到了泛型，但是定义构造器的时候不能用<>菱形语法
		public People(T t){
			this.t=t;
		}
	}
	//这是使用的时候，使用的时候就必须为类型形参指定确切的值
	class Person extends People<String>{
		public Person(String s){
			super(s);
		}
	}   
定义接口和定义类一样。但是在定义构造器的时候**一定不能使用菱形语法**，可以理解为构造器内部在初始化成员的时候可能不涉及到使用到了泛型的成员；但是在调用构造器的时候**可以使用菱形语法**，这里也仅仅是*可以*，说明也是有可能初始化的时候没有初始化那个泛型的成员，所以就没必要用菱形语法了。  
同样也可以定义一个泛型方法，当一个类或者接口没有使用类型参数，但定义方法的时候想自己定义类型形参，也是可以的。实现的方法是在**方法的返回值类型之前，访问修饰符之后使用菱形语法**：  

	public <T>　void getName(T t);
##使用的时候  
泛型在使用的时候必须指明类型才行，常见的“使用”情况：  

* 继承具有泛型的父类的时候，父类必须在菱形语法中指明泛型的具体类型：class Person extends People<String>  
* 使用带泛型的类或者接口来创建变量的时候:People<String> p;  
   