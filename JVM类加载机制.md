#JVM之类加载机制  
参考文章：  
>https://mp.weixin.qq.com/s/rLooaTOU_NQTJdn28KAUFw
##1. 什么是类的加载  
类的加载是将类的.class文件中的二进制数据读取到内存中，将其放在**运行时数据区的方法区**内（关于运行时数据区，方法区等的只是将在jvm的内存模型中讲到）。**类加载的最终产品是位于堆栈内的Class对象，Class对象封装了类在方法区的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。**（感悟：这就从一方面说明了为什么Java内存模型中jvm堆的空间最大，因为，使用一个类时可能需要创建很多对象，而这些对象所封装的数据都指向了方法区中的那个）。  
*思考题：定义一个工具类，所有的方法和数据都是静态的，而且构造器用private修饰，那么我通过"类名.方法名"或者"类名.变量名"访问数据，是不是也是通过这个java.lang.Class对象*
![](https://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnokxXiapDdvntH8PGwa0zGXMqaq9p1LDCF7iadMBibd685uYCy8u0yhb5dmlvLRwgzNueNdSdWdvEwww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)  
  
####加载.class的方式  

* 从本地系统中加载  
* 通过网络下载.class文件  
* 从zip，jar等归档文件中加载.class文件  
* 从专有数据库中提取.class文件  
* 将Java源文件编译为.class文件  
##2. 类的生命周期  
![](https://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnokxXiapDdvntH8PGwa0zGXMyIBnM38m8eKia8wAVY8aXb0NhM9wFNDLVuoFKIZ0Q2SBk5yibFgXsXOw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&retryload=1)  
###2.1 加载阶段  
查找并加载类的二进制数据是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以一下三件事情：  

* 通过一个类的权限定名来获取其定义的二进制字节流  
* 将这个字节流所代表的静态储存结构转化为**方法区**的运行时数据结构  
* 在Java堆中生成一个代表这个**类的java.lang.Class对象**（注意：这个java.lang.class对象不同于new关键字创建出来的对象，涉及到反射的知识），作为**对方法区中这些数据区的访问入口**  
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区内，而且在Java堆中也创建一个Class类的对象，这样就可以通过该对象访问方法区中的这些数据。  
###2.2 链接  
####2.2.1 验证：确保被加载的类的正确性  
验证是链接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：  

* **文件格式的验证**：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。  
* **元数据的验证**：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。 
* **字节码的验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。  
* **符号引用的验证**：确保解析动作能正确执行  
验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。  
####2.2.2 准备：为类的静态变量分配内存，并为其初始化为默认值  
准备阶段是正式为**类变量**分配内存并设置类变量的**初始值**（*注：这里是初始值，不是直接就默认值*）；通常情况下初始值就是默认值（如0，null，false等），但是，如果在声明一个**静态常量**，那么初始值就是指定的那个值。  
理解：  
* 静态量和普通量的区别：准备阶段是为静态量分配内存，以及初始化的阶段。并不涉及到普通变量的事情。比如：public static int a;public int b;经过了这个阶段后a有了内存空间，并且a被赋予了0值；但是，b却啥都没有变化。  
* 静态常量和讲台变量的区别：准备阶段在为静态量初始化的时候，如果是一个静态常量，就不会初始化为默认值，而是初始化为指定的值。public static final int a=3;public static int b=3;在经过了准备阶段后，a的值变为了3，但是b的值却是0，将b赋值为3的阶段是类加载的初始化阶段。（*感悟：这就理解了为什么在声明static final修饰的量时要显示的为其赋值，因为如果不这样的话，他就被赋值为了默认值，也就没了意义*）。