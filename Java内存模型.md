#Java内存模型  
##1 Java内存模型（JMM）  
###1.1 概念  
Java内存模型是一个抽象的概念，并非真实存在，它涵盖了缓存，写缓存区，寄存器以及其他的硬件和编译器的优化  
###1.2 作用  
* 控制线程间的通信，决定了一个线程对共享变量的写入何时对另一个线程可见  
* 定义了线程和主内存之间的抽象关系：  
	* 线程之间的共享变量存储在主内存中（从硬件的角度来说就是内存条）  
	* 每个线程都有一个私有的本地内存，本地内存中存储了该线程用来读/写共享变量的副本（从硬件角度来说就是CPU的缓存，比如寄存器，L1，L2，L3缓存等）  
* JMM屏蔽各个硬件平台和操作系统的内存访问差异  
###1.3 核心原则  
* 原子性  
* 可见性  
* 有序性  
####1.3.1 原子性  
* 是指一个操作是不可中断的，即多线程环境下操作不能被其他线程干扰  
####1.3.2 可见性  
* 是指当一个线程修改了某一个共享变量的值，其他线程是否能够**立即知道**该变更 
*  Java提供volatile保证可见性：写操作立即刷新到主内存，读操作直接从主内存读取  
*  Java同时还可以通过加锁的同步性间接保证可见性：synchronized和Lock能保证同一时刻只有一个线程获取锁并执行同步代码，并在释放锁之后将变量的修改刷新到主内存中
* Java中普通的共享变量不保证可见性，因为其的修改被写入内存的时机是不确定的，多线程并发下很可能出现"脏读"  
		
		public class Test {
			static int a=0;
			public static void main(String[] args)
			{
				Thread thread=new Thread(new Runnable(){

					public void run() {
						// TODO Auto-generated method stub
						for(;Test.a<100;Test.a++)
						{
							System.out.println(Thread.currentThread().getName()+"----"+Test.a);
						}
					}
			
				},"线程1");
				Thread th=new Thread(new Runnable(){

					public void run() {
						// TODO Auto-generated method stub
						for(;Test.a<100;Test.a++)
						{
							System.out.println(Thread.currentThread().getName()+"-----"+Test.a);
						}
					}
			
				},"线程2");
				thread.start();
				th.start();
		---------  
		输出（一部分）：  
		线程2-----24
		线程1----25
		线程1----27
		线程1----28
		线程2-----26
		线程1----29  
可以看到当线程1对a的改变，线程2有时不会立刻知道，这就是写入的不确定性  
####1.3.3 有序性  
* 对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行
* 但为了提供性能，编译器和处理器通常会对指令序列进行重新排序
* 指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生"脏读"  
###1.4 抽象结构  
![](http://static.zybuluo.com/kiraSally/0tmogigvobjwm3nq784lnm8z/JMM.jpg)    
##2 重排序  
###2.1 数据依赖性和串行语义  
* 数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。  
* 编译器和处理器在重排序时，会遵守数据依赖性，**不会改变存在依赖关系的两个操作的执行**。但**不同处理器和不同线程之间的数据性**不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境  
###2.2 串行语义  
* 串行语义： 不管如何重排序，单线程的执行结果不能被改变，编译器和处理器必须遵守串行语义
* 不存在依赖关系，可以重排序；存在依赖关系，禁止重排序  
###2.3 重排序  
* 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段
* 为了提高效率，指令序列执行遵循流水线模式，不同的指令交给不同的硬件处理，从而节省等待时间
* 但流水线最害怕被中断(所有硬件设备会进入停顿期，再次满载又需要几个周期，性能损失很大)，而**重排序就是减少中断的一种重要手段**
* **但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！**  
###2.4 重排序的分类  
* 编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序  
* 指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
* 内存系统的重排序： 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行  
###2.5 重排序的执行流程  
![](http://static.zybuluo.com/kiraSally/oz4u8e5lrvb1p8t2l26mpoih/image_1bnl122f613nr9php3411dv50u5n.png)  
##3 Happends-Before  
从JDK5开始，JAVA使用心得JSR-133内存模型，其使用happens-before的概念来阐述操作之间的内存可见性.
在JMM中，若一个操作执行的结果需要对另一个操作可见，那么这两个操作至今必须存在happens-before关系.
happens-before为指令重排制订了必须遵守的8项规则，在这些规则约束下，确保并非所有的指令都可以随意改变执行位置，进而保证操作结果的最终一致性（即不管重排与否，结果一致）.A Happens-Before B 前一个操作(A)的结果必须对后一个操作(B)可见，且前一个操作按顺序排在第二个顺序之前（但JMM并不要求A一定要在B之前执行）  
###3.1 Happends-Before原则  
*  指令重排是有原则的，并非所有的指令都可以随便改变执行位置，如以下情况：
*  **程序顺序原则(！！)：** 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
*  **volatile规则(！！)：** volatile变量的写先发生于读，这保证了volatile变量的可见性
*  **锁规则(！！)：** 解锁必然发生在随后的加锁之前
*  **传递规则(！！)：** A先于B，B先于C，那么A必然先于C
*  **线程启动规则：** 线程的start()方法先于它的每一个动作
*  **线程中断规则：** 线程的中断(Thread.interrupt())先于被中断线程的代码
*  **线程终止规则：** 线程的所有操作先于线程的终止检测(Thread.join()方法结束，Thread.isAlive()检测)
*  **对象终结规则：** 对象的构造函数执行(初始化)结束先于finalize()方法